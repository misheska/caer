// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_EVENT_DV_H_
#define FLATBUFFERS_GENERATED_EVENT_DV_H_

#include "cvector.hpp"
#include "flatbuffers/flatbuffers.h"

namespace dv {

struct Event;

struct EventPacket;
struct EventPacketT;

inline const flatbuffers::TypeTable *EventTypeTable();

inline const flatbuffers::TypeTable *EventPacketTypeTable();

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Event FLATBUFFERS_FINAL_CLASS {
private:
	int64_t timestamp_;
	int16_t x_;
	int16_t y_;
	uint8_t polarity_;
	int8_t padding0__;
	int16_t padding1__;

public:
	Event() {
		memset(static_cast<void *>(this), 0, sizeof(Event));
	}
	Event(int64_t _timestamp, int16_t _x, int16_t _y, bool _polarity) :
		timestamp_(flatbuffers::EndianScalar(_timestamp)),
		x_(flatbuffers::EndianScalar(_x)),
		y_(flatbuffers::EndianScalar(_y)),
		polarity_(flatbuffers::EndianScalar(static_cast<uint8_t>(_polarity))),
		padding0__(0),
		padding1__(0) {
		(void) padding0__;
		(void) padding1__;
	}
	/// Timestamp (Âµs).
	int64_t timestamp() const {
		return flatbuffers::EndianScalar(timestamp_);
	}
	int16_t x() const {
		return flatbuffers::EndianScalar(x_);
	}
	int16_t y() const {
		return flatbuffers::EndianScalar(y_);
	}
	bool polarity() const {
		return flatbuffers::EndianScalar(polarity_) != 0;
	}
};
FLATBUFFERS_STRUCT_END(Event, 16);

struct EventPacketT : public flatbuffers::NativeTable {
	typedef EventPacket TableType;
	dv::cvector<Event> events;
	EventPacketT() {
	}
};

struct EventPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef EventPacketT NativeTableType;
	static const char *identifier;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return EventPacketTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_EVENTS = 4 };
	const flatbuffers::Vector<const Event *> *events() const {
		return GetPointer<const flatbuffers::Vector<const Event *> *>(VT_EVENTS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_EVENTS) && verifier.VerifyVector(events())
			   && verifier.EndTable();
	}
	EventPacketT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(EventPacketT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static void UnPackToFrom(
		EventPacketT *_o, const EventPacket *_fb, const flatbuffers::resolver_function_t *_resolver = nullptr);
	static flatbuffers::Offset<EventPacket> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventPacketT *_o,
		const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EventPacketBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_events(flatbuffers::Offset<flatbuffers::Vector<const Event *>> events) {
		fbb_.AddOffset(EventPacket::VT_EVENTS, events);
	}
	explicit EventPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	EventPacketBuilder &operator=(const EventPacketBuilder &);
	flatbuffers::Offset<EventPacket> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o         = flatbuffers::Offset<EventPacket>(end);
		return o;
	}
};

inline flatbuffers::Offset<EventPacket> CreateEventPacket(
	flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<const Event *>> events = 0) {
	EventPacketBuilder builder_(_fbb);
	builder_.add_events(events);
	return builder_.Finish();
}

inline flatbuffers::Offset<EventPacket> CreateEventPacketDirect(
	flatbuffers::FlatBufferBuilder &_fbb, const std::vector<Event> *events = nullptr) {
	auto events__ = events ? _fbb.CreateVectorOfStructs<Event>(*events) : 0;
	return dv::CreateEventPacket(_fbb, events__);
}

flatbuffers::Offset<EventPacket> CreateEventPacket(flatbuffers::FlatBufferBuilder &_fbb, const EventPacketT *_o,
	const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EventPacketT *EventPacket::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new EventPacketT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void EventPacket::UnPackTo(EventPacketT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void) _o;
	(void) _resolver;
	UnPackToFrom(_o, this, _resolver);
}

inline void EventPacket::UnPackToFrom(
	EventPacketT *_o, const EventPacket *_fb, const flatbuffers::resolver_function_t *_resolver) {
	(void) _o;
	(void) _fb;
	(void) _resolver;
	{
		auto _e = _fb->events();
		if (_e) {
			_o->events.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->events[_i] = *_e->Get(_i);
			}
		}
	};
}

inline flatbuffers::Offset<EventPacket> EventPacket::Pack(
	flatbuffers::FlatBufferBuilder &_fbb, const EventPacketT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateEventPacket(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EventPacket> CreateEventPacket(
	flatbuffers::FlatBufferBuilder &_fbb, const EventPacketT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void) _rehasher;
	(void) _o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const EventPacketT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void) _va;
	auto _events = _o->events.size() ? _fbb.CreateVectorOfStructs(_o->events.data(), _o->events.size()) : 0;
	return dv::CreateEventPacket(_fbb, _events);
}

inline const flatbuffers::TypeTable *EventTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_LONG, 0, -1}, {flatbuffers::ET_SHORT, 0, -1},
		{flatbuffers::ET_SHORT, 0, -1}, {flatbuffers::ET_BOOL, 0, -1}};
	static const int64_t values[]                   = {0, 8, 10, 12, 16};
	static const char *const names[]                = {"timestamp", "x", "y", "polarity"};
	static const flatbuffers::TypeTable tt          = {flatbuffers::ST_STRUCT, 4, type_codes, nullptr, values, names};
	return &tt;
}

inline const flatbuffers::TypeTable *EventPacketTypeTable() {
	static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_SEQUENCE, 1, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {EventTypeTable};
	static const char *const names[]                   = {"events"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
	return &tt;
}

inline const dv::EventPacket *GetEventPacket(const void *buf) {
	return flatbuffers::GetRoot<dv::EventPacket>(buf);
}

inline const dv::EventPacket *GetSizePrefixedEventPacket(const void *buf) {
	return flatbuffers::GetSizePrefixedRoot<dv::EventPacket>(buf);
}

inline const char *EventPacketIdentifier() {
	return "EVTS";
}

const char *EventPacket::identifier = EventPacketIdentifier();

inline bool EventPacketBufferHasIdentifier(const void *buf) {
	return flatbuffers::BufferHasIdentifier(buf, EventPacketIdentifier());
}

inline bool VerifyEventPacketBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<dv::EventPacket>(EventPacketIdentifier());
}

inline bool VerifySizePrefixedEventPacketBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<dv::EventPacket>(EventPacketIdentifier());
}

inline void FinishEventPacketBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<dv::EventPacket> root) {
	fbb.Finish(root, EventPacketIdentifier());
}

inline void FinishSizePrefixedEventPacketBuffer(
	flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<dv::EventPacket> root) {
	fbb.FinishSizePrefixed(root, EventPacketIdentifier());
}

inline std::unique_ptr<EventPacketT> UnPackEventPacket(
	const void *buf, const flatbuffers::resolver_function_t *res = nullptr) {
	return std::unique_ptr<EventPacketT>(GetEventPacket(buf)->UnPack(res));
}

} // namespace dv

#endif // FLATBUFFERS_GENERATED_EVENT_DV_H_
