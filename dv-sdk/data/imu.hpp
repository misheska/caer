// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_IMU_DV_H_
#define FLATBUFFERS_GENERATED_IMU_DV_H_

#include "cvector.hpp"
#include "flatbuffers/flatbuffers.h"

namespace dv {

struct IMU;
struct IMUT;

struct IMUPacket;
struct IMUPacketT;

bool operator==(const IMUT &lhs, const IMUT &rhs);
bool operator==(const IMUPacketT &lhs, const IMUPacketT &rhs);

inline const flatbuffers::TypeTable *IMUTypeTable();

inline const flatbuffers::TypeTable *IMUPacketTypeTable();

struct IMUT : public flatbuffers::NativeTable {
	typedef IMU TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.IMUT";
	}
	int64_t timestamp;
	float temperature;
	float accelerometerX;
	float accelerometerY;
	float accelerometerZ;
	float gyroscopeX;
	float gyroscopeY;
	float gyroscopeZ;
	float magnetometerX;
	float magnetometerY;
	float magnetometerZ;
	IMUT() :
		timestamp(0),
		temperature(0.0f),
		accelerometerX(0.0f),
		accelerometerY(0.0f),
		accelerometerZ(0.0f),
		gyroscopeX(0.0f),
		gyroscopeY(0.0f),
		gyroscopeZ(0.0f),
		magnetometerX(0.0f),
		magnetometerY(0.0f),
		magnetometerZ(0.0f) {
	}
};

inline bool operator==(const IMUT &lhs, const IMUT &rhs) {
	return (lhs.timestamp == rhs.timestamp) && (lhs.temperature == rhs.temperature)
		   && (lhs.accelerometerX == rhs.accelerometerX) && (lhs.accelerometerY == rhs.accelerometerY)
		   && (lhs.accelerometerZ == rhs.accelerometerZ) && (lhs.gyroscopeX == rhs.gyroscopeX)
		   && (lhs.gyroscopeY == rhs.gyroscopeY) && (lhs.gyroscopeZ == rhs.gyroscopeZ)
		   && (lhs.magnetometerX == rhs.magnetometerX) && (lhs.magnetometerY == rhs.magnetometerY)
		   && (lhs.magnetometerZ == rhs.magnetometerZ);
}

struct IMU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef IMUT NativeTableType;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return IMUTypeTable();
	}
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.IMU";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TIMESTAMP      = 4,
		VT_TEMPERATURE    = 6,
		VT_ACCELEROMETERX = 8,
		VT_ACCELEROMETERY = 10,
		VT_ACCELEROMETERZ = 12,
		VT_GYROSCOPEX     = 14,
		VT_GYROSCOPEY     = 16,
		VT_GYROSCOPEZ     = 18,
		VT_MAGNETOMETERX  = 20,
		VT_MAGNETOMETERY  = 22,
		VT_MAGNETOMETERZ  = 24
	};
	/// Timestamp (µs).
	int64_t timestamp() const {
		return GetField<int64_t>(VT_TIMESTAMP, 0);
	}
	/// Temperature, measured in °C.
	float temperature() const {
		return GetField<float>(VT_TEMPERATURE, 0.0f);
	}
	/// Acceleration in the X axis, measured in g (9.81m/s²).
	float accelerometerX() const {
		return GetField<float>(VT_ACCELEROMETERX, 0.0f);
	}
	/// Acceleration in the Y axis, measured in g (9.81m/s²).
	float accelerometerY() const {
		return GetField<float>(VT_ACCELEROMETERY, 0.0f);
	}
	/// Acceleration in the Z axis, measured in g (9.81m/s²).
	float accelerometerZ() const {
		return GetField<float>(VT_ACCELEROMETERZ, 0.0f);
	}
	/// Rotation in the X axis, measured in °/s.
	float gyroscopeX() const {
		return GetField<float>(VT_GYROSCOPEX, 0.0f);
	}
	/// Rotation in the Y axis, measured in °/s.
	float gyroscopeY() const {
		return GetField<float>(VT_GYROSCOPEY, 0.0f);
	}
	/// Rotation in the Z axis, measured in °/s.
	float gyroscopeZ() const {
		return GetField<float>(VT_GYROSCOPEZ, 0.0f);
	}
	/// Magnetometer X axis, measured in µT (magnetic flux density).
	float magnetometerX() const {
		return GetField<float>(VT_MAGNETOMETERX, 0.0f);
	}
	/// Magnetometer Y axis, measured in µT (magnetic flux density).
	float magnetometerY() const {
		return GetField<float>(VT_MAGNETOMETERY, 0.0f);
	}
	/// Magnetometer Z axis, measured in µT (magnetic flux density).
	float magnetometerZ() const {
		return GetField<float>(VT_MAGNETOMETERZ, 0.0f);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_TIMESTAMP)
			   && VerifyField<float>(verifier, VT_TEMPERATURE) && VerifyField<float>(verifier, VT_ACCELEROMETERX)
			   && VerifyField<float>(verifier, VT_ACCELEROMETERY) && VerifyField<float>(verifier, VT_ACCELEROMETERZ)
			   && VerifyField<float>(verifier, VT_GYROSCOPEX) && VerifyField<float>(verifier, VT_GYROSCOPEY)
			   && VerifyField<float>(verifier, VT_GYROSCOPEZ) && VerifyField<float>(verifier, VT_MAGNETOMETERX)
			   && VerifyField<float>(verifier, VT_MAGNETOMETERY) && VerifyField<float>(verifier, VT_MAGNETOMETERZ)
			   && verifier.EndTable();
	}
	IMUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(IMUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static void UnPackToFrom(IMUT *_o, const IMU *_fb, const flatbuffers::resolver_function_t *_resolver = nullptr);
	static flatbuffers::Offset<IMU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IMUT *_o,
		const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IMUBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_timestamp(int64_t timestamp) {
		fbb_.AddElement<int64_t>(IMU::VT_TIMESTAMP, timestamp, 0);
	}
	void add_temperature(float temperature) {
		fbb_.AddElement<float>(IMU::VT_TEMPERATURE, temperature, 0.0f);
	}
	void add_accelerometerX(float accelerometerX) {
		fbb_.AddElement<float>(IMU::VT_ACCELEROMETERX, accelerometerX, 0.0f);
	}
	void add_accelerometerY(float accelerometerY) {
		fbb_.AddElement<float>(IMU::VT_ACCELEROMETERY, accelerometerY, 0.0f);
	}
	void add_accelerometerZ(float accelerometerZ) {
		fbb_.AddElement<float>(IMU::VT_ACCELEROMETERZ, accelerometerZ, 0.0f);
	}
	void add_gyroscopeX(float gyroscopeX) {
		fbb_.AddElement<float>(IMU::VT_GYROSCOPEX, gyroscopeX, 0.0f);
	}
	void add_gyroscopeY(float gyroscopeY) {
		fbb_.AddElement<float>(IMU::VT_GYROSCOPEY, gyroscopeY, 0.0f);
	}
	void add_gyroscopeZ(float gyroscopeZ) {
		fbb_.AddElement<float>(IMU::VT_GYROSCOPEZ, gyroscopeZ, 0.0f);
	}
	void add_magnetometerX(float magnetometerX) {
		fbb_.AddElement<float>(IMU::VT_MAGNETOMETERX, magnetometerX, 0.0f);
	}
	void add_magnetometerY(float magnetometerY) {
		fbb_.AddElement<float>(IMU::VT_MAGNETOMETERY, magnetometerY, 0.0f);
	}
	void add_magnetometerZ(float magnetometerZ) {
		fbb_.AddElement<float>(IMU::VT_MAGNETOMETERZ, magnetometerZ, 0.0f);
	}
	explicit IMUBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	IMUBuilder &operator=(const IMUBuilder &);
	flatbuffers::Offset<IMU> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o         = flatbuffers::Offset<IMU>(end);
		return o;
	}
};

inline flatbuffers::Offset<IMU> CreateIMU(flatbuffers::FlatBufferBuilder &_fbb, int64_t timestamp = 0,
	float temperature = 0.0f, float accelerometerX = 0.0f, float accelerometerY = 0.0f, float accelerometerZ = 0.0f,
	float gyroscopeX = 0.0f, float gyroscopeY = 0.0f, float gyroscopeZ = 0.0f, float magnetometerX = 0.0f,
	float magnetometerY = 0.0f, float magnetometerZ = 0.0f) {
	IMUBuilder builder_(_fbb);
	builder_.add_timestamp(timestamp);
	builder_.add_magnetometerZ(magnetometerZ);
	builder_.add_magnetometerY(magnetometerY);
	builder_.add_magnetometerX(magnetometerX);
	builder_.add_gyroscopeZ(gyroscopeZ);
	builder_.add_gyroscopeY(gyroscopeY);
	builder_.add_gyroscopeX(gyroscopeX);
	builder_.add_accelerometerZ(accelerometerZ);
	builder_.add_accelerometerY(accelerometerY);
	builder_.add_accelerometerX(accelerometerX);
	builder_.add_temperature(temperature);
	return builder_.Finish();
}

flatbuffers::Offset<IMU> CreateIMU(
	flatbuffers::FlatBufferBuilder &_fbb, const IMUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IMUPacketT : public flatbuffers::NativeTable {
	typedef IMUPacket TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.IMUPacketT";
	}
	dv::cvector<IMUT> samples;
	IMUPacketT() {
	}
};

inline bool operator==(const IMUPacketT &lhs, const IMUPacketT &rhs) {
	return (lhs.samples == rhs.samples);
}

struct IMUPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef IMUPacketT NativeTableType;
	static const char *identifier;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return IMUPacketTypeTable();
	}
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.IMUPacket";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_SAMPLES = 4 };
	const flatbuffers::Vector<flatbuffers::Offset<IMU>> *samples() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<IMU>> *>(VT_SAMPLES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SAMPLES) && verifier.VerifyVector(samples())
			   && verifier.VerifyVectorOfTables(samples()) && verifier.EndTable();
	}
	IMUPacketT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(IMUPacketT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static void UnPackToFrom(
		IMUPacketT *_o, const IMUPacket *_fb, const flatbuffers::resolver_function_t *_resolver = nullptr);
	static flatbuffers::Offset<IMUPacket> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IMUPacketT *_o,
		const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IMUPacketBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_samples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IMU>>> samples) {
		fbb_.AddOffset(IMUPacket::VT_SAMPLES, samples);
	}
	explicit IMUPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	IMUPacketBuilder &operator=(const IMUPacketBuilder &);
	flatbuffers::Offset<IMUPacket> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o         = flatbuffers::Offset<IMUPacket>(end);
		return o;
	}
};

inline flatbuffers::Offset<IMUPacket> CreateIMUPacket(flatbuffers::FlatBufferBuilder &_fbb,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IMU>>> samples = 0) {
	IMUPacketBuilder builder_(_fbb);
	builder_.add_samples(samples);
	return builder_.Finish();
}

inline flatbuffers::Offset<IMUPacket> CreateIMUPacketDirect(
	flatbuffers::FlatBufferBuilder &_fbb, const std::vector<flatbuffers::Offset<IMU>> *samples = nullptr) {
	auto samples__ = samples ? _fbb.CreateVector<flatbuffers::Offset<IMU>>(*samples) : 0;
	return dv::CreateIMUPacket(_fbb, samples__);
}

flatbuffers::Offset<IMUPacket> CreateIMUPacket(flatbuffers::FlatBufferBuilder &_fbb, const IMUPacketT *_o,
	const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline IMUT *IMU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new IMUT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void IMU::UnPackTo(IMUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void) _o;
	(void) _resolver;
	UnPackToFrom(_o, this, _resolver);
}

inline void IMU::UnPackToFrom(IMUT *_o, const IMU *_fb, const flatbuffers::resolver_function_t *_resolver) {
	(void) _o;
	(void) _fb;
	(void) _resolver;
	{
		auto _e       = _fb->timestamp();
		_o->timestamp = _e;
	};
	{
		auto _e         = _fb->temperature();
		_o->temperature = _e;
	};
	{
		auto _e            = _fb->accelerometerX();
		_o->accelerometerX = _e;
	};
	{
		auto _e            = _fb->accelerometerY();
		_o->accelerometerY = _e;
	};
	{
		auto _e            = _fb->accelerometerZ();
		_o->accelerometerZ = _e;
	};
	{
		auto _e        = _fb->gyroscopeX();
		_o->gyroscopeX = _e;
	};
	{
		auto _e        = _fb->gyroscopeY();
		_o->gyroscopeY = _e;
	};
	{
		auto _e        = _fb->gyroscopeZ();
		_o->gyroscopeZ = _e;
	};
	{
		auto _e           = _fb->magnetometerX();
		_o->magnetometerX = _e;
	};
	{
		auto _e           = _fb->magnetometerY();
		_o->magnetometerY = _e;
	};
	{
		auto _e           = _fb->magnetometerZ();
		_o->magnetometerZ = _e;
	};
}

inline flatbuffers::Offset<IMU> IMU::Pack(
	flatbuffers::FlatBufferBuilder &_fbb, const IMUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateIMU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IMU> CreateIMU(
	flatbuffers::FlatBufferBuilder &_fbb, const IMUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void) _rehasher;
	(void) _o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const IMUT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void) _va;
	auto _timestamp      = _o->timestamp;
	auto _temperature    = _o->temperature;
	auto _accelerometerX = _o->accelerometerX;
	auto _accelerometerY = _o->accelerometerY;
	auto _accelerometerZ = _o->accelerometerZ;
	auto _gyroscopeX     = _o->gyroscopeX;
	auto _gyroscopeY     = _o->gyroscopeY;
	auto _gyroscopeZ     = _o->gyroscopeZ;
	auto _magnetometerX  = _o->magnetometerX;
	auto _magnetometerY  = _o->magnetometerY;
	auto _magnetometerZ  = _o->magnetometerZ;
	return dv::CreateIMU(_fbb, _timestamp, _temperature, _accelerometerX, _accelerometerY, _accelerometerZ, _gyroscopeX,
		_gyroscopeY, _gyroscopeZ, _magnetometerX, _magnetometerY, _magnetometerZ);
}

inline IMUPacketT *IMUPacket::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new IMUPacketT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void IMUPacket::UnPackTo(IMUPacketT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void) _o;
	(void) _resolver;
	UnPackToFrom(_o, this, _resolver);
}

inline void IMUPacket::UnPackToFrom(
	IMUPacketT *_o, const IMUPacket *_fb, const flatbuffers::resolver_function_t *_resolver) {
	(void) _o;
	(void) _fb;
	(void) _resolver;
	{
		auto _e = _fb->samples();
		if (_e) {
			_o->samples.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_e->Get(_i)->UnPackTo(&_o->samples[_i], _resolver);
			}
		}
	};
}

inline flatbuffers::Offset<IMUPacket> IMUPacket::Pack(
	flatbuffers::FlatBufferBuilder &_fbb, const IMUPacketT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateIMUPacket(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IMUPacket> CreateIMUPacket(
	flatbuffers::FlatBufferBuilder &_fbb, const IMUPacketT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void) _rehasher;
	(void) _o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const IMUPacketT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void) _va;
	auto _samples = _o->samples.size()
						? _fbb.CreateVector<flatbuffers::Offset<IMU>>(_o->samples.size(),
							  [](size_t i, _VectorArgs *__va) {
								  return CreateIMU(*__va->__fbb, &__va->__o->samples[i], __va->__rehasher);
							  },
							  &_va)
						: 0;
	return dv::CreateIMUPacket(_fbb, _samples);
}

inline const flatbuffers::TypeTable *IMUTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_LONG, 0, -1}, {flatbuffers::ET_FLOAT, 0, -1},
		{flatbuffers::ET_FLOAT, 0, -1}, {flatbuffers::ET_FLOAT, 0, -1}, {flatbuffers::ET_FLOAT, 0, -1},
		{flatbuffers::ET_FLOAT, 0, -1}, {flatbuffers::ET_FLOAT, 0, -1}, {flatbuffers::ET_FLOAT, 0, -1},
		{flatbuffers::ET_FLOAT, 0, -1}, {flatbuffers::ET_FLOAT, 0, -1}, {flatbuffers::ET_FLOAT, 0, -1}};
	static const char *const names[]                = {"timestamp", "temperature", "accelerometerX", "accelerometerY",
        "accelerometerZ", "gyroscopeX", "gyroscopeY", "gyroscopeZ", "magnetometerX", "magnetometerY", "magnetometerZ"};
	static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *IMUPacketTypeTable() {
	static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_SEQUENCE, 1, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {IMUTypeTable};
	static const char *const names[]                   = {"samples"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
	return &tt;
}

inline const dv::IMUPacket *GetIMUPacket(const void *buf) {
	return flatbuffers::GetRoot<dv::IMUPacket>(buf);
}

inline const dv::IMUPacket *GetSizePrefixedIMUPacket(const void *buf) {
	return flatbuffers::GetSizePrefixedRoot<dv::IMUPacket>(buf);
}

inline const char *IMUPacketIdentifier() {
	return "IMUS";
}

const char *IMUPacket::identifier = IMUPacketIdentifier();

inline bool IMUPacketBufferHasIdentifier(const void *buf) {
	return flatbuffers::BufferHasIdentifier(buf, IMUPacketIdentifier());
}

inline bool VerifyIMUPacketBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<dv::IMUPacket>(IMUPacketIdentifier());
}

inline bool VerifySizePrefixedIMUPacketBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<dv::IMUPacket>(IMUPacketIdentifier());
}

inline void FinishIMUPacketBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<dv::IMUPacket> root) {
	fbb.Finish(root, IMUPacketIdentifier());
}

inline void FinishSizePrefixedIMUPacketBuffer(
	flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<dv::IMUPacket> root) {
	fbb.FinishSizePrefixed(root, IMUPacketIdentifier());
}

inline std::unique_ptr<IMUPacketT> UnPackIMUPacket(
	const void *buf, const flatbuffers::resolver_function_t *res = nullptr) {
	return std::unique_ptr<IMUPacketT>(GetIMUPacket(buf)->UnPack(res));
}

} // namespace dv

#endif // FLATBUFFERS_GENERATED_IMU_DV_H_
