// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_TEST_H_
#define FLATBUFFERS_GENERATED_TEST_H_

#include "cstring.hpp"
#include "cvector.hpp"
#include "flatbuffers/flatbuffers.h"

struct Test;
struct TestT;

struct TestPacket;
struct TestPacketT;

inline const flatbuffers::TypeTable *TestTypeTable();

inline const flatbuffers::TypeTable *TestPacketTypeTable();

struct TestT : public flatbuffers::NativeTable {
	typedef Test TableType;
	int64_t timestamp;
	int16_t addressX;
	int16_t addressY;
	bool polarity;
	dv::cstring astr;
	dv::cvector<bool> aboolvec;
	dv::cvector<int32_t> aintvec;
	dv::cvector<dv::cstring> astrvec;
	TestT() : timestamp(0), addressX(0), addressY(0), polarity(false) {
	}
};

struct Test FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TestT NativeTableType;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return TestTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TIMESTAMP = 4,
		VT_ADDRESSX  = 6,
		VT_ADDRESSY  = 8,
		VT_POLARITY  = 10,
		VT_ASTR      = 12,
		VT_ABOOLVEC  = 14,
		VT_AINTVEC   = 16,
		VT_ASTRVEC   = 18
	};
	int64_t timestamp() const {
		return GetField<int64_t>(VT_TIMESTAMP, 0);
	}
	int16_t addressX() const {
		return GetField<int16_t>(VT_ADDRESSX, 0);
	}
	int16_t addressY() const {
		return GetField<int16_t>(VT_ADDRESSY, 0);
	}
	bool polarity() const {
		return GetField<uint8_t>(VT_POLARITY, 0) != 0;
	}
	const flatbuffers::String *astr() const {
		return GetPointer<const flatbuffers::String *>(VT_ASTR);
	}
	const flatbuffers::Vector<uint8_t> *aboolvec() const {
		return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ABOOLVEC);
	}
	const flatbuffers::Vector<int32_t> *aintvec() const {
		return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AINTVEC);
	}
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *astrvec() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ASTRVEC);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_TIMESTAMP)
			   && VerifyField<int16_t>(verifier, VT_ADDRESSX) && VerifyField<int16_t>(verifier, VT_ADDRESSY)
			   && VerifyField<uint8_t>(verifier, VT_POLARITY) && VerifyOffset(verifier, VT_ASTR)
			   && verifier.VerifyString(astr()) && VerifyOffset(verifier, VT_ABOOLVEC)
			   && verifier.VerifyVector(aboolvec()) && VerifyOffset(verifier, VT_AINTVEC)
			   && verifier.VerifyVector(aintvec()) && VerifyOffset(verifier, VT_ASTRVEC)
			   && verifier.VerifyVector(astrvec()) && verifier.VerifyVectorOfStrings(astrvec()) && verifier.EndTable();
	}
	TestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Test> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestT *_o,
		const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_timestamp(int64_t timestamp) {
		fbb_.AddElement<int64_t>(Test::VT_TIMESTAMP, timestamp, 0);
	}
	void add_addressX(int16_t addressX) {
		fbb_.AddElement<int16_t>(Test::VT_ADDRESSX, addressX, 0);
	}
	void add_addressY(int16_t addressY) {
		fbb_.AddElement<int16_t>(Test::VT_ADDRESSY, addressY, 0);
	}
	void add_polarity(bool polarity) {
		fbb_.AddElement<uint8_t>(Test::VT_POLARITY, static_cast<uint8_t>(polarity), 0);
	}
	void add_astr(flatbuffers::Offset<flatbuffers::String> astr) {
		fbb_.AddOffset(Test::VT_ASTR, astr);
	}
	void add_aboolvec(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> aboolvec) {
		fbb_.AddOffset(Test::VT_ABOOLVEC, aboolvec);
	}
	void add_aintvec(flatbuffers::Offset<flatbuffers::Vector<int32_t>> aintvec) {
		fbb_.AddOffset(Test::VT_AINTVEC, aintvec);
	}
	void add_astrvec(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> astrvec) {
		fbb_.AddOffset(Test::VT_ASTRVEC, astrvec);
	}
	explicit TestBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	TestBuilder &operator=(const TestBuilder &);
	flatbuffers::Offset<Test> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o         = flatbuffers::Offset<Test>(end);
		return o;
	}
};

inline flatbuffers::Offset<Test> CreateTest(flatbuffers::FlatBufferBuilder &_fbb, int64_t timestamp = 0,
	int16_t addressX = 0, int16_t addressY = 0, bool polarity = false,
	flatbuffers::Offset<flatbuffers::String> astr = 0, flatbuffers::Offset<flatbuffers::Vector<uint8_t>> aboolvec = 0,
	flatbuffers::Offset<flatbuffers::Vector<int32_t>> aintvec                                  = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> astrvec = 0) {
	TestBuilder builder_(_fbb);
	builder_.add_timestamp(timestamp);
	builder_.add_astrvec(astrvec);
	builder_.add_aintvec(aintvec);
	builder_.add_aboolvec(aboolvec);
	builder_.add_astr(astr);
	builder_.add_addressY(addressY);
	builder_.add_addressX(addressX);
	builder_.add_polarity(polarity);
	return builder_.Finish();
}

inline flatbuffers::Offset<Test> CreateTestDirect(flatbuffers::FlatBufferBuilder &_fbb, int64_t timestamp = 0,
	int16_t addressX = 0, int16_t addressY = 0, bool polarity = false, const char *astr = nullptr,
	const std::vector<uint8_t> *aboolvec = nullptr, const std::vector<int32_t> *aintvec = nullptr,
	const std::vector<flatbuffers::Offset<flatbuffers::String>> *astrvec = nullptr) {
	auto astr__     = astr ? _fbb.CreateString(astr) : 0;
	auto aboolvec__ = aboolvec ? _fbb.CreateVector<uint8_t>(*aboolvec) : 0;
	auto aintvec__  = aintvec ? _fbb.CreateVector<int32_t>(*aintvec) : 0;
	auto astrvec__  = astrvec ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*astrvec) : 0;
	return CreateTest(_fbb, timestamp, addressX, addressY, polarity, astr__, aboolvec__, aintvec__, astrvec__);
}

flatbuffers::Offset<Test> CreateTest(
	flatbuffers::FlatBufferBuilder &_fbb, const TestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TestPacketT : public flatbuffers::NativeTable {
	typedef TestPacket TableType;
	dv::cvector<TestT *> events;
	TestPacketT() {
	}
};

struct TestPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TestPacketT NativeTableType;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return TestPacketTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_EVENTS = 4 };
	const flatbuffers::Vector<flatbuffers::Offset<Test>> *events() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Test>> *>(VT_EVENTS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_EVENTS) && verifier.VerifyVector(events())
			   && verifier.VerifyVectorOfTables(events()) && verifier.EndTable();
	}
	TestPacketT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TestPacketT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TestPacket> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestPacketT *_o,
		const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestPacketBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_events(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Test>>> events) {
		fbb_.AddOffset(TestPacket::VT_EVENTS, events);
	}
	explicit TestPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	TestPacketBuilder &operator=(const TestPacketBuilder &);
	flatbuffers::Offset<TestPacket> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o         = flatbuffers::Offset<TestPacket>(end);
		return o;
	}
};

inline flatbuffers::Offset<TestPacket> CreateTestPacket(flatbuffers::FlatBufferBuilder &_fbb,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Test>>> events = 0) {
	TestPacketBuilder builder_(_fbb);
	builder_.add_events(events);
	return builder_.Finish();
}

inline flatbuffers::Offset<TestPacket> CreateTestPacketDirect(
	flatbuffers::FlatBufferBuilder &_fbb, const std::vector<flatbuffers::Offset<Test>> *events = nullptr) {
	auto events__ = events ? _fbb.CreateVector<flatbuffers::Offset<Test>>(*events) : 0;
	return CreateTestPacket(_fbb, events__);
}

flatbuffers::Offset<TestPacket> CreateTestPacket(flatbuffers::FlatBufferBuilder &_fbb, const TestPacketT *_o,
	const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TestT *Test::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new TestT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void Test::UnPackTo(TestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void) _o;
	(void) _resolver;
	{
		auto _e       = timestamp();
		_o->timestamp = _e;
	};
	{
		auto _e      = addressX();
		_o->addressX = _e;
	};
	{
		auto _e      = addressY();
		_o->addressY = _e;
	};
	{
		auto _e      = polarity();
		_o->polarity = _e;
	};
	{
		auto _e = astr();
		if (_e)
			_o->astr = dv::cstring(_e->c_str(), _e->size());
	};
	{
		auto _e = aboolvec();
		if (_e) {
			_o->aboolvec.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->aboolvec[_i] = _e->Get(_i) != 0;
			}
		}
	};
	{
		auto _e = aintvec();
		if (_e) {
			_o->aintvec.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->aintvec[_i] = _e->Get(_i);
			}
		}
	};
	{
		auto _e = astrvec();
		if (_e) {
			_o->astrvec.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->astrvec[_i] = dv::cstring(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	};
}

inline flatbuffers::Offset<Test> Test::Pack(
	flatbuffers::FlatBufferBuilder &_fbb, const TestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Test> CreateTest(
	flatbuffers::FlatBufferBuilder &_fbb, const TestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void) _rehasher;
	(void) _o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TestT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void) _va;
	auto _timestamp = _o->timestamp;
	auto _addressX  = _o->addressX;
	auto _addressY  = _o->addressY;
	auto _polarity  = _o->polarity;
	auto _astr      = _o->astr.empty() ? 0 : _fbb.CreateString(_o->astr);
	auto _aboolvec  = _o->aboolvec.size()
						 ? _fbb.CreateVectorScalarCast<uint8_t, bool>(_o->aboolvec.data(), _o->aboolvec.size())
						 : 0;
	auto _aintvec = _o->aintvec.size() ? _fbb.CreateVector(_o->aintvec.data(), _o->aintvec.size()) : 0;
	auto _astrvec
		= _o->astrvec.size()
			  ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(_o->astrvec.size(),
					[](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->astrvec[i]); }, &_va)
			  : 0;
	return CreateTest(_fbb, _timestamp, _addressX, _addressY, _polarity, _astr, _aboolvec, _aintvec, _astrvec);
}

inline TestPacketT *TestPacket::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new TestPacketT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void TestPacket::UnPackTo(TestPacketT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void) _o;
	(void) _resolver;
	{
		auto _e = events();
		if (_e) {
			_o->events.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->events[_i] = (_e->Get(_i)->UnPack(_resolver));
			}
		}
	};
}

inline flatbuffers::Offset<TestPacket> TestPacket::Pack(
	flatbuffers::FlatBufferBuilder &_fbb, const TestPacketT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTestPacket(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TestPacket> CreateTestPacket(
	flatbuffers::FlatBufferBuilder &_fbb, const TestPacketT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void) _rehasher;
	(void) _o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TestPacketT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void) _va;
	auto _events = _o->events.size() ? _fbb.CreateVector<flatbuffers::Offset<Test>>(_o->events.size(),
										   [](size_t i, _VectorArgs *__va) {
											   return CreateTest(*__va->__fbb, __va->__o->events[i], __va->__rehasher);
										   },
										   &_va)
									 : 0;
	return CreateTestPacket(_fbb, _events);
}

inline const flatbuffers::TypeTable *TestTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_LONG, 0, -1}, {flatbuffers::ET_SHORT, 0, -1},
		{flatbuffers::ET_SHORT, 0, -1}, {flatbuffers::ET_BOOL, 0, -1}, {flatbuffers::ET_STRING, 0, -1},
		{flatbuffers::ET_BOOL, 1, -1}, {flatbuffers::ET_INT, 1, -1}, {flatbuffers::ET_STRING, 1, -1}};
	static const char *const names[]
		= {"timestamp", "addressX", "addressY", "polarity", "astr", "aboolvec", "aintvec", "astrvec"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *TestPacketTypeTable() {
	static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_SEQUENCE, 1, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {TestTypeTable};
	static const char *const names[]                   = {"events"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
	return &tt;
}

inline const TestPacket *GetTestPacket(const void *buf) {
	return flatbuffers::GetRoot<TestPacket>(buf);
}

inline const TestPacket *GetSizePrefixedTestPacket(const void *buf) {
	return flatbuffers::GetSizePrefixedRoot<TestPacket>(buf);
}

inline const char *TestPacketIdentifier() {
	return "TEST";
}

inline bool TestPacketBufferHasIdentifier(const void *buf) {
	return flatbuffers::BufferHasIdentifier(buf, TestPacketIdentifier());
}

inline bool VerifyTestPacketBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<TestPacket>(TestPacketIdentifier());
}

inline bool VerifySizePrefixedTestPacketBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<TestPacket>(TestPacketIdentifier());
}

inline void FinishTestPacketBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<TestPacket> root) {
	fbb.Finish(root, TestPacketIdentifier());
}

inline void FinishSizePrefixedTestPacketBuffer(
	flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<TestPacket> root) {
	fbb.FinishSizePrefixed(root, TestPacketIdentifier());
}

inline TestPacketT *UnPackTestPacket(const void *buf, const flatbuffers::resolver_function_t *res = nullptr) {
	return (GetTestPacket(buf)->UnPack(res));
}

#endif // FLATBUFFERS_GENERATED_TEST_H_
